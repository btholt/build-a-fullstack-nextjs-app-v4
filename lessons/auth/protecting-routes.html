<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png" data-next-head=""/><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png" data-next-head=""/><link rel="icon" type="image/x-icon" href="/images/favicon.ico" data-next-head=""/><title data-next-head="">Protecting Routes – Build a Fullstack Next.js App, v4</title><meta name="description" content="Build a production-ready team wiki from scratch using Next.js, TypeScript, and modern SaaS tools. Master authentication, database integration, AI features, and deployment patterns." data-next-head=""/><meta name="keywords" content="Next.js,fullstack,React,TypeScript,authentication,database,Postgres,Vercel,deployment,SaaS,AI integration,modern web development" data-next-head=""/><meta name="og:description" content="Build a production-ready team wiki from scratch using Next.js, TypeScript, and modern SaaS tools. Master authentication, database integration, AI features, and deployment patterns." data-next-head=""/><meta name="og:title" content="Protecting Routes – Build a Fullstack Next.js App, v4" data-next-head=""/><meta name="og:image" content="/images/social-share-cover.jpg" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/de2ef606dd4d4a67.css" as="style"/><link rel="stylesheet" href="/_next/static/css/de2ef606dd4d4a67.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-b66ed8ba6f029a99.js" defer=""></script><script src="/_next/static/chunks/framework-b1e5f14688f9ffe6.js" defer=""></script><script src="/_next/static/chunks/main-953f8078176d6f7b.js" defer=""></script><script src="/_next/static/chunks/pages/_app-04cfcdd17f247960.js" defer=""></script><script src="/_next/static/chunks/pages/lessons/%5Bsection%5D/%5Bslug%5D-e3f3acd10ab352ae.js" defer=""></script><script src="/_next/static/XOcKuB9gZ84DgFGtHvLgN/_buildManifest.js" defer=""></script><script src="/_next/static/XOcKuB9gZ84DgFGtHvLgN/_ssgManifest.js" defer=""></script></head><body><script async="" defer="" src="https://a.holt.courses/latest.js"></script><div id="__next"><div class="remix-app"><header class="navbar"><h1 class="navbar-brand"><a href="/">Build a Fullstack Next.js App, v4</a></h1><div class="navbar-info"><a href="https://frontendmasters.com/workshops/fullstack-app-next-v4/" class="cta-btn">Watch on Frontend Masters</a></div></header><div class="content-container"><div class="main"><div class="lesson-container"><div class="lesson"><div class="lesson-content"><p>We need to protect our edit page. Right now any anonymous user can load that page which is not what we want - if you are logged out, we want you to log in first before we let you edit.</p>
<blockquote>
<p>We haven&#39;t set up the database yet so we&#39;ll only just be differentiating between logged in and logged out. We&#39;ll revisit when we add the database to restrict edits to your articles only or allow admins to edit any article.</p>
</blockquote>
<p>There are three ways to protect a route with Stack Auth (and I&#39;d say it&#39;s pretty generally true for all of Next.js): client-side, server-side, or middleware.</p>
<h2>Client Side</h2>
<p>A client-side redirect will look like <code>useUser({ or: &#39;redirect&#39; });</code>. This tells Next.js &quot;hey, if there&#39;s no user here, just redirect them to log in&quot;. You can also redirect them anywhere, but this is the most common thing you&#39;d do. This works just fine in many cases and is a good user experience as the client can immediately redirect a user without a roundtrip to the server.</p>
<p>What&#39;s wrong with client side redirects? The code for these pages is all still sent to the browser, regardless if a user can access it or not. If the page contains sensitive data or shows off hidden endpoints that you may not want to leak or anything that truly is sensitive, you don&#39;t want to do this as any attacker could load up your JS and find whatever info you were trying to protect.</p>
<p>In our case it&#39;s totally fine - we&#39;re not trying to hide the editor from anyone, we just don&#39;t don&#39;t want to show to anyone who wouldn&#39;t be able to use it. We can absolutely use a client side redirect here.</p>
<h2>Server Side</h2>
<p>Likewise a server side redirect will look like <code>await stackServerApp.getUser({ or: &#39;redirect&#39; });</code>. This will make sure it all happens on the server and anything inside the component can be guaranteed not to be sent to the user unless they pass the login test. You&#39;ll find yourself doing this for React Server Components.</p>
<p>Something similar will likely also be done for API routes should you choose to implement those. In that case you&#39;ll do <code>await stackServerApp.getUser()</code> and then do a Next.js redirect if the user object doesn&#39;t exist.</p>
<p>Again, it&#39;s important to note, all of these are plenty secure - no one is going to be able to impersonate someone else, but it&#39;s just a matter if you care that the components are being sent down and not used for a user that doesn&#39;t pass the authorization.</p>
<h2>Middleware</h2>
<p>The code for this will look like</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// from the stack auth docs</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params"><span class="hljs-attr">request</span>: <span class="hljs-title class_">NextRequest</span></span>) {
  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> stackServerApp.<span class="hljs-title function_">getUser</span>();
  <span class="hljs-keyword">if</span> (!user) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">redirect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&quot;/handler/sign-in&quot;</span>, request.<span class="hljs-property">url</span>));
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>();
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> config = {
  <span class="hljs-comment">// You can add your own route protection logic here</span>
  <span class="hljs-comment">// Make sure not to protect the root URL, as it would prevent users from accessing static Next.js files or Stack&#x27;s /handler path</span>
  <span class="hljs-attr">matcher</span>: <span class="hljs-string">&quot;/protected/:path*&quot;</span>,
};
</code></pre><p>This is what you&#39;d do if you wanted to protect a whole block of routes. In the case of the example code above, you&#39;d be gating access to <code>/protected/&lt;anything&gt;</code> so you wouldn&#39;t have to do it on each page. We won&#39;t do this today, but I wanted to let you know you don&#39;t have to do it page-by-page, you can do it in blocks too with middleware.</p>
<p>So let&#39;s go do it for our app!</p>
<p>In <code>/src/app/wiki/edit/[id]/page.tsx</code> put this</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// at top</span>
<span class="hljs-keyword">import</span> { stackServerApp } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/stack/server&quot;</span>;

<span class="hljs-comment">// under pulling the id out of params</span>
<span class="hljs-keyword">await</span> stackServerApp.<span class="hljs-title function_">getUser</span>({ <span class="hljs-attr">or</span>: <span class="hljs-string">&quot;redirect&quot;</span> });

<span class="hljs-comment">// we&#x27;ll uncomment this later when the articles have real IDs</span>
<span class="hljs-comment">// if (user.id !== id) {</span>
<span class="hljs-comment">//   stackServerApp.redirectToHome();</span>
<span class="hljs-comment">// }</span>
</code></pre><p>This lets us either get the user object back from Stack Auth or, if it doesn&#39;t exist because they aren&#39;t logged in, redirects them to sign in or sign up. We put in the commented code because we can&#39;t yet check that because the articles don&#39;t have valid IDs, but when they do it will just send the user to the home page. In theory we should probably have a Forbidden page, but for now this is fine.</p>
<p>Okay, let&#39;s go do the new/page.tsx too</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// at top</span>
<span class="hljs-keyword">import</span> { stackServerApp } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/stack/server&quot;</span>;

<span class="hljs-comment">// replace function, add async</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">NewArticlePage</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">await</span> stackServerApp.<span class="hljs-title function_">getUser</span>({ <span class="hljs-attr">or</span>: <span class="hljs-string">&quot;redirect&quot;</span> });
    ...
}
</code></pre><p>The same! And there you go, we&#39;ve protected our pages with server-side redirects! We did server-side because our pages were already React Server Components and there was no reason to convert them; client-side would have been just fine.</p>
<h2>Server Actions</h2>
<p>We have some server actions to accept new and edited articles as well as image uploads. Just because those are server actions does not mean we can leave them unprotected. In reality they&#39;re just API endpoints too, even if they&#39;re not exposed as restful endpoints. Let&#39;s go protect those too (as it works mostly the same way too.)</p>
<p>For <strong>both actions/upload.ts and actions/articles.ts</strong> do the following</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// add import to the top</span>
<span class="hljs-keyword">import</span> { stackServerApp } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/stack/server&quot;</span>;

<span class="hljs-comment">// add this to the top of every action function</span>
<span class="hljs-keyword">const</span> user = stackServerApp.<span class="hljs-title function_">getUser</span>();
<span class="hljs-keyword">if</span> (!user) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;❌ Unauthorized&quot;</span>);
}
</code></pre><p>This still only checks that the user has logged in - we&#39;re still letting any user edit any article, but we&#39;ll get there soon. But that is auth! Congrats!</p>
<blockquote>
<p>🏁 This is the <a href="https://github.com/btholt/fullstack-next-wiki/tree/main/03-auth">03-auth</a> checkpoint. Open that folder in the sample project repo to go to where we are as of right here.</p>
</blockquote>
</div><div class="lesson-links"><a href="/lessons/auth/signin-and-signup" class="prev">← Previous</a><a href="/lessons/database/neon-and-postgres" class="next">Next →</a></div></div><div class="details-bg"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="154" height="154" viewBox="0 0 154 154"><defs><clipPath id="clip-path"><rect id="Rectangle_2238" data-name="Rectangle 2238" width="154" height="154" transform="translate(9467 350)" fill="#fff" stroke="#707070" stroke-width="1"></rect></clipPath><clipPath id="clip-corner-image-active"><rect width="154" height="154"></rect></clipPath></defs><g id="corner-image-active" clip-path="url(#clip-corner-image-active)"><g id="Corner-image-active-2" data-name="Corner-image-active" transform="translate(-9467 -350)" clip-path="url(#clip-path)"><path id="Subtraction_34" data-name="Subtraction 34" d="M-3857.365,1740.766h0l-7.07-7.07,12.89-12.89v14.142l-5.818,5.818Zm-14.142-14.142h0l-7.071-7.07,27.033-27.033v14.143l-19.96,19.96Zm-14.143-14.143h0l-7.07-7.069,41.175-41.175v14.142Zm-14.142-14.142h0l-7.07-7.069,55.317-55.317v14.142Zm-14.142-14.142h0l-7.07-7.069,69.459-69.459v14.142Zm-14.142-14.142h0l-7.07-7.069,76.739-76.739h6.862v7.28Zm-14.143-14.143h0l-7.07-7.069,62.6-62.6h14.142Zm-14.142-14.142h0l-7.07-7.069,48.454-48.454h14.142Zm-14.142-14.142h0l-7.07-7.069,34.312-34.312h14.142Zm-14.142-14.142h0l-7.07-7.069,20.17-20.17h14.142Zm-14.142-14.142h0l-7.071-7.071,6.027-6.027h14.144l-13.1,13.1Zm367.24-56.114v-.909l.455.455-.453.453Z" transform="translate(13472.546 -1236.766)" fill="var(--corner-fill)"></path></g></g></svg></div></div></div></div><noscript><img src="https://a.holt.courses/noscript.gif" alt="" referrerPolicy="no-referrer-when-downgrade"/></noscript><footer class="footer"><ul class="socials"><li class="social"><a href="https://twitter.com/holtbt"><svg fill="none" height="100%" width="32" xmlns="http://www.w3.org/2000/svg" viewBox="0.254 0.25 500 451.95400000000006"><path d="M394.033.25h76.67L303.202 191.693l197.052 260.511h-154.29L225.118 294.205 86.844 452.204H10.127l179.16-204.77L.254.25H158.46l109.234 144.417zm-26.908 406.063h42.483L135.377 43.73h-45.59z" fill="var(--footer-icons)"></path></svg></a></li><li class="social"><a href="https://bsky.app/profile/brianholt.me"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -3.268 64 68.414" width="38" height="100%"><path fill="var(--footer-icons)" d="M13.873 3.805C21.21 9.332 29.103 20.537 32 26.55v15.882c0-.338-.13.044-.41.867-1.512 4.456-7.418 21.847-20.923 7.944-7.111-7.32-3.819-14.64 9.125-16.85-7.405 1.264-15.73-.825-18.014-9.015C1.12 23.022 0 8.51 0 6.55 0-3.268 8.579-.182 13.873 3.805zm36.254 0C42.79 9.332 34.897 20.537 32 26.55v15.882c0-.338.13.044.41.867 1.512 4.456 7.418 21.847 20.923 7.944 7.111-7.32 3.819-14.64-9.125-16.85 7.405 1.264 15.73-.825 18.014-9.015C62.88 23.022 64 8.51 64 6.55c0-9.818-8.578-6.732-13.873-2.745z"></path></svg></a></li><li class="social"><a href="https://github.com/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-github-social"><rect width="32" height="32"></rect></clipPath></defs><g id="github-social" clip-path="url(#clip-github-social)"><g id="Group_272" data-name="Group 272" transform="translate(13522.5 -6994)"><path id="Subtraction_33" data-name="Subtraction 33" d="M-24967.5,8041a15.9,15.9,0,0,1-11.312-4.688A15.893,15.893,0,0,1-24983.5,8025a15.893,15.893,0,0,1,4.689-11.315A15.894,15.894,0,0,1-24967.5,8009a15.894,15.894,0,0,1,11.313,4.686A15.893,15.893,0,0,1-24951.5,8025a15.893,15.893,0,0,1-4.689,11.313A15.9,15.9,0,0,1-24967.5,8041Zm-3.781-4.571h0v3.918h7.895v-6.665a1.836,1.836,0,0,0-1.2-1.718c5.1-.617,7.467-2.975,7.467-7.424a7.176,7.176,0,0,0-1.637-4.728,6.74,6.74,0,0,0,.275-1.812,4.34,4.34,0,0,0-.52-2.452.574.574,0,0,0-.359-.1c-1.061,0-3.465,1.411-3.936,1.694a16.644,16.644,0,0,0-4.2-.489,16.379,16.379,0,0,0-3.969.445c-.846-.5-2.91-1.649-3.859-1.649a.566.566,0,0,0-.354.095,4.3,4.3,0,0,0-.521,2.452,6.7,6.7,0,0,0,.244,1.718,7.346,7.346,0,0,0-1.6,4.822,7.263,7.263,0,0,0,1.533,4.985c1.193,1.359,3.115,2.165,5.871,2.464a1.826,1.826,0,0,0-1.129,1.693v.5h0l-.006,0a7.121,7.121,0,0,1-2.033.363,2.608,2.608,0,0,1-.965-.158,4.438,4.438,0,0,1-1.836-1.881,2.361,2.361,0,0,0-1.248-1.091,3.472,3.472,0,0,0-1.217-.3.584.584,0,0,0-.545.224.282.282,0,0,0,.027.367,1.875,1.875,0,0,0,.447.307,4.732,4.732,0,0,1,.561.355,10.726,10.726,0,0,1,1.682,2.755c.043.092.078.163.105.217a3.876,3.876,0,0,0,2.42,1.185,6.036,6.036,0,0,0,.607.025c.875,0,1.988-.124,2-.125Z" transform="translate(11461 -1015)" fill="var(--footer-icons)"></path><g id="Ellipse_670" data-name="Ellipse 670" transform="translate(-13522.5 6994)" fill="none" stroke="var(--footer-icons)" stroke-width="1"><circle cx="16" cy="16" r="16" stroke="none"></circle><circle cx="16" cy="16" r="15.5" fill="none"></circle></g></g></g></svg></a></li><li class="social"><a href="https://linkedin.com/in/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-linkedin-social"><rect width="32" height="32"></rect></clipPath></defs><g id="linkedin-social" clip-path="url(#clip-linkedin-social)"><g id="Group_270" data-name="Group 270" transform="translate(-86.349 -633.073)"><path id="Path_375" data-name="Path 375" d="M115.789,633.073a2.324,2.324,0,0,1,1.682.676,2.194,2.194,0,0,1,.695,1.627V662.8a2.131,2.131,0,0,1-.695,1.609,2.314,2.314,0,0,1-1.646.659H88.69a2.307,2.307,0,0,1-1.646-.659,2.128,2.128,0,0,1-.695-1.609V635.376a2.19,2.19,0,0,1,.695-1.627,2.322,2.322,0,0,1,1.682-.676h27.063Zm-20.224,9.672a2.561,2.561,0,0,0,0-3.584,2.658,2.658,0,0,0-1.938-.712,2.724,2.724,0,0,0-1.957.712,2.371,2.371,0,0,0-.75,1.792,2.4,2.4,0,0,0,.731,1.792,2.605,2.605,0,0,0,1.9.713h.037A2.7,2.7,0,0,0,95.565,642.745ZM96,645.434H91.213V659.88H96Zm17.3,6.144a7.007,7.007,0,0,0-1.573-4.9,5.68,5.68,0,0,0-6.839-.769,5.663,5.663,0,0,0-1.426,1.573v-2.048H98.674q.036.841,0,7.717v6.728h4.791V651.8a3.592,3.592,0,0,1,.146-1.17,2.913,2.913,0,0,1,.878-1.206,2.429,2.429,0,0,1,1.609-.549,2.108,2.108,0,0,1,1.865.914,4.265,4.265,0,0,1,.549,2.341v7.752H113.3Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><div class="terms"><p>Content Licensed Under CC-BY-NC-4.0</p><p>Code Samples and Exercises Licensed Under Apache 2.0</p><p>Site Designed by<!-- --> <a href="https://www.alexdanielson.com/">Alex Danielson</a></p></div></li></ul><div class="theme-icons"><link id="highlight-theme-light" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.8.0/styles/a11y-light.min.css"/><link id="highlight-theme-dark" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.8.0/styles/a11y-dark.min.css" disabled=""/><button aria-label="Activate dark mode" title="Activate dark mode" class="theme-toggle"><svg xmlns="http://www.w3.org/2000/svg" width="36px" height="100%" viewBox="0 -960 960 960" fill="var(--text-footer)" role="img"><title>Dark Mode Icon</title><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Z"></path></svg></button></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"attributes":{},"html":"\u003cp\u003eWe need to protect our edit page. Right now any anonymous user can load that page which is not what we want - if you are logged out, we want you to log in first before we let you edit.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWe haven\u0026#39;t set up the database yet so we\u0026#39;ll only just be differentiating between logged in and logged out. We\u0026#39;ll revisit when we add the database to restrict edits to your articles only or allow admins to edit any article.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThere are three ways to protect a route with Stack Auth (and I\u0026#39;d say it\u0026#39;s pretty generally true for all of Next.js): client-side, server-side, or middleware.\u003c/p\u003e\n\u003ch2\u003eClient Side\u003c/h2\u003e\n\u003cp\u003eA client-side redirect will look like \u003ccode\u003euseUser({ or: \u0026#39;redirect\u0026#39; });\u003c/code\u003e. This tells Next.js \u0026quot;hey, if there\u0026#39;s no user here, just redirect them to log in\u0026quot;. You can also redirect them anywhere, but this is the most common thing you\u0026#39;d do. This works just fine in many cases and is a good user experience as the client can immediately redirect a user without a roundtrip to the server.\u003c/p\u003e\n\u003cp\u003eWhat\u0026#39;s wrong with client side redirects? The code for these pages is all still sent to the browser, regardless if a user can access it or not. If the page contains sensitive data or shows off hidden endpoints that you may not want to leak or anything that truly is sensitive, you don\u0026#39;t want to do this as any attacker could load up your JS and find whatever info you were trying to protect.\u003c/p\u003e\n\u003cp\u003eIn our case it\u0026#39;s totally fine - we\u0026#39;re not trying to hide the editor from anyone, we just don\u0026#39;t don\u0026#39;t want to show to anyone who wouldn\u0026#39;t be able to use it. We can absolutely use a client side redirect here.\u003c/p\u003e\n\u003ch2\u003eServer Side\u003c/h2\u003e\n\u003cp\u003eLikewise a server side redirect will look like \u003ccode\u003eawait stackServerApp.getUser({ or: \u0026#39;redirect\u0026#39; });\u003c/code\u003e. This will make sure it all happens on the server and anything inside the component can be guaranteed not to be sent to the user unless they pass the login test. You\u0026#39;ll find yourself doing this for React Server Components.\u003c/p\u003e\n\u003cp\u003eSomething similar will likely also be done for API routes should you choose to implement those. In that case you\u0026#39;ll do \u003ccode\u003eawait stackServerApp.getUser()\u003c/code\u003e and then do a Next.js redirect if the user object doesn\u0026#39;t exist.\u003c/p\u003e\n\u003cp\u003eAgain, it\u0026#39;s important to note, all of these are plenty secure - no one is going to be able to impersonate someone else, but it\u0026#39;s just a matter if you care that the components are being sent down and not used for a user that doesn\u0026#39;t pass the authorization.\u003c/p\u003e\n\u003ch2\u003eMiddleware\u003c/h2\u003e\n\u003cp\u003eThe code for this will look like\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// from the stack auth docs\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emiddleware\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-attr\"\u003erequest\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eNextRequest\u003c/span\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e stackServerApp.\u003cspan class=\"hljs-title function_\"\u003egetUser\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!user) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eredirect\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eURL\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;/handler/sign-in\u0026quot;\u003c/span\u003e, request.\u003cspan class=\"hljs-property\"\u003eurl\u003c/span\u003e));\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e();\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e config = {\n  \u003cspan class=\"hljs-comment\"\u003e// You can add your own route protection logic here\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// Make sure not to protect the root URL, as it would prevent users from accessing static Next.js files or Stack\u0026#x27;s /handler path\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ematcher\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;/protected/:path*\u0026quot;\u003c/span\u003e,\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is what you\u0026#39;d do if you wanted to protect a whole block of routes. In the case of the example code above, you\u0026#39;d be gating access to \u003ccode\u003e/protected/\u0026lt;anything\u0026gt;\u003c/code\u003e so you wouldn\u0026#39;t have to do it on each page. We won\u0026#39;t do this today, but I wanted to let you know you don\u0026#39;t have to do it page-by-page, you can do it in blocks too with middleware.\u003c/p\u003e\n\u003cp\u003eSo let\u0026#39;s go do it for our app!\u003c/p\u003e\n\u003cp\u003eIn \u003ccode\u003e/src/app/wiki/edit/[id]/page.tsx\u003c/code\u003e put this\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// at top\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { stackServerApp } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;@/stack/server\u0026quot;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// under pulling the id out of params\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e stackServerApp.\u003cspan class=\"hljs-title function_\"\u003egetUser\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003eor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;redirect\u0026quot;\u003c/span\u003e });\n\n\u003cspan class=\"hljs-comment\"\u003e// we\u0026#x27;ll uncomment this later when the articles have real IDs\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// if (user.id !== id) {\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//   stackServerApp.redirectToHome();\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// }\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis lets us either get the user object back from Stack Auth or, if it doesn\u0026#39;t exist because they aren\u0026#39;t logged in, redirects them to sign in or sign up. We put in the commented code because we can\u0026#39;t yet check that because the articles don\u0026#39;t have valid IDs, but when they do it will just send the user to the home page. In theory we should probably have a Forbidden page, but for now this is fine.\u003c/p\u003e\n\u003cp\u003eOkay, let\u0026#39;s go do the new/page.tsx too\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// at top\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { stackServerApp } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;@/stack/server\u0026quot;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// replace function, add async\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eNewArticlePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e stackServerApp.\u003cspan class=\"hljs-title function_\"\u003egetUser\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003eor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;redirect\u0026quot;\u003c/span\u003e });\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe same! And there you go, we\u0026#39;ve protected our pages with server-side redirects! We did server-side because our pages were already React Server Components and there was no reason to convert them; client-side would have been just fine.\u003c/p\u003e\n\u003ch2\u003eServer Actions\u003c/h2\u003e\n\u003cp\u003eWe have some server actions to accept new and edited articles as well as image uploads. Just because those are server actions does not mean we can leave them unprotected. In reality they\u0026#39;re just API endpoints too, even if they\u0026#39;re not exposed as restful endpoints. Let\u0026#39;s go protect those too (as it works mostly the same way too.)\u003c/p\u003e\n\u003cp\u003eFor \u003cstrong\u003eboth actions/upload.ts and actions/articles.ts\u003c/strong\u003e do the following\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// add import to the top\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { stackServerApp } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;@/stack/server\u0026quot;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// add this to the top of every action function\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = stackServerApp.\u003cspan class=\"hljs-title function_\"\u003egetUser\u003c/span\u003e();\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!user) {\n  \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;❌ Unauthorized\u0026quot;\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis still only checks that the user has logged in - we\u0026#39;re still letting any user edit any article, but we\u0026#39;ll get there soon. But that is auth! Congrats!\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e🏁 This is the \u003ca href=\"https://github.com/btholt/fullstack-next-wiki/tree/main/03-auth\"\u003e03-auth\u003c/a\u003e checkpoint. Open that folder in the sample project repo to go to where we are as of right here.\u003c/p\u003e\n\u003c/blockquote\u003e\n","markdown":"We need to protect our edit page. Right now any anonymous user can load that page which is not what we want - if you are logged out, we want you to log in first before we let you edit.\n\n\u003e We haven't set up the database yet so we'll only just be differentiating between logged in and logged out. We'll revisit when we add the database to restrict edits to your articles only or allow admins to edit any article.\n\nThere are three ways to protect a route with Stack Auth (and I'd say it's pretty generally true for all of Next.js): client-side, server-side, or middleware.\n\n## Client Side\n\nA client-side redirect will look like `useUser({ or: 'redirect' });`. This tells Next.js \"hey, if there's no user here, just redirect them to log in\". You can also redirect them anywhere, but this is the most common thing you'd do. This works just fine in many cases and is a good user experience as the client can immediately redirect a user without a roundtrip to the server.\n\nWhat's wrong with client side redirects? The code for these pages is all still sent to the browser, regardless if a user can access it or not. If the page contains sensitive data or shows off hidden endpoints that you may not want to leak or anything that truly is sensitive, you don't want to do this as any attacker could load up your JS and find whatever info you were trying to protect.\n\nIn our case it's totally fine - we're not trying to hide the editor from anyone, we just don't don't want to show to anyone who wouldn't be able to use it. We can absolutely use a client side redirect here.\n\n## Server Side\n\nLikewise a server side redirect will look like `await stackServerApp.getUser({ or: 'redirect' });`. This will make sure it all happens on the server and anything inside the component can be guaranteed not to be sent to the user unless they pass the login test. You'll find yourself doing this for React Server Components.\n\nSomething similar will likely also be done for API routes should you choose to implement those. In that case you'll do `await stackServerApp.getUser()` and then do a Next.js redirect if the user object doesn't exist.\n\nAgain, it's important to note, all of these are plenty secure - no one is going to be able to impersonate someone else, but it's just a matter if you care that the components are being sent down and not used for a user that doesn't pass the authorization.\n\n## Middleware\n\nThe code for this will look like\n\n```typescript\n// from the stack auth docs\nexport async function middleware(request: NextRequest) {\n  const user = await stackServerApp.getUser();\n  if (!user) {\n    return NextResponse.redirect(new URL(\"/handler/sign-in\", request.url));\n  }\n  return NextResponse.next();\n}\n\nexport const config = {\n  // You can add your own route protection logic here\n  // Make sure not to protect the root URL, as it would prevent users from accessing static Next.js files or Stack's /handler path\n  matcher: \"/protected/:path*\",\n};\n```\n\nThis is what you'd do if you wanted to protect a whole block of routes. In the case of the example code above, you'd be gating access to `/protected/\u003canything\u003e` so you wouldn't have to do it on each page. We won't do this today, but I wanted to let you know you don't have to do it page-by-page, you can do it in blocks too with middleware.\n\nSo let's go do it for our app!\n\nIn `/src/app/wiki/edit/[id]/page.tsx` put this\n\n```typescript\n// at top\nimport { stackServerApp } from \"@/stack/server\";\n\n// under pulling the id out of params\nawait stackServerApp.getUser({ or: \"redirect\" });\n\n// we'll uncomment this later when the articles have real IDs\n// if (user.id !== id) {\n//   stackServerApp.redirectToHome();\n// }\n```\n\nThis lets us either get the user object back from Stack Auth or, if it doesn't exist because they aren't logged in, redirects them to sign in or sign up. We put in the commented code because we can't yet check that because the articles don't have valid IDs, but when they do it will just send the user to the home page. In theory we should probably have a Forbidden page, but for now this is fine.\n\nOkay, let's go do the new/page.tsx too\n\n```typescript\n// at top\nimport { stackServerApp } from \"@/stack/server\";\n\n// replace function, add async\nexport default async function NewArticlePage() {\n    await stackServerApp.getUser({ or: \"redirect\" });\n    ...\n}\n```\n\nThe same! And there you go, we've protected our pages with server-side redirects! We did server-side because our pages were already React Server Components and there was no reason to convert them; client-side would have been just fine.\n\n## Server Actions\n\nWe have some server actions to accept new and edited articles as well as image uploads. Just because those are server actions does not mean we can leave them unprotected. In reality they're just API endpoints too, even if they're not exposed as restful endpoints. Let's go protect those too (as it works mostly the same way too.)\n\nFor **both actions/upload.ts and actions/articles.ts** do the following\n\n```typescript\n// add import to the top\nimport { stackServerApp } from \"@/stack/server\";\n\n// add this to the top of every action function\nconst user = stackServerApp.getUser();\nif (!user) {\n  throw new Error(\"❌ Unauthorized\");\n}\n```\n\nThis still only checks that the user has logged in - we're still letting any user edit any article, but we'll get there soon. But that is auth! Congrats!\n\n\u003e 🏁 This is the [03-auth][checkpoint] checkpoint. Open that folder in the sample project repo to go to where we are as of right here.\n\n[checkpoint]: https://github.com/btholt/fullstack-next-wiki/tree/main/03-auth\n","slug":"protecting-routes","title":"Protecting Routes","section":"Auth","icon":"user-lock","filePath":"/home/runner/work/build-a-fullstack-nextjs-app-v4/build-a-fullstack-nextjs-app-v4/lessons/03-auth/B-protecting-routes.md","nextSlug":"/lessons/database/neon-and-postgres","prevSlug":"/lessons/auth/signin-and-signup"}},"__N_SSG":true},"page":"/lessons/[section]/[slug]","query":{"section":"auth","slug":"protecting-routes"},"buildId":"XOcKuB9gZ84DgFGtHvLgN","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>