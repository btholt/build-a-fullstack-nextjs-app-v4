{"pageProps":{"post":{"attributes":{},"html":"<p>So, now we have a problem - we have some records that have AI summary records, and some that don&#39;t. Maybe we make those summary updates low priority, or maybe they fail on some normal interval. What can we do about that? We could make it check on reads but that slows down a critical path. What we could do better is schedule a job to run on some reoccurring basis, essentially a <a href=\"https://btholt.github.io/complete-intro-to-linux-and-the-cli/cron\">cron job</a>.</p>\n<p>Vercel has a very easy way to do cron jobs for Next.js apps. You just define an API function and Vercel will call the API function for you. Vercel will put in a special variable so you can make sure it&#39;s only Vercel that will call the function too (we don&#39;t want random people invoking our jobs.)</p>\n<p>Let&#39;s do it! Let&#39;s make a job that runs weekly to make sure that all items in the database have summaries.</p>\n<blockquote>\n<p>Why weekly? Every time this runs it&#39;ll wake your Vercel and Neon instances, costing you money or free tier credit. I chose weekly because adding a few minutes week isn&#39;t too bad. If you ran this every minute you&#39;d eat through both Vercel and Neon&#39;s free tiers.</p>\n</blockquote>\n<p>In src/app, create a new folder, <code>api</code>. In the api directory, make a new directory, <code>summary</code>. In there, create a new file, <code>route.ts</code>.</p>\n<p>In there put:</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">NextRequest</span>, <span class=\"hljs-title class_\">NextResponse</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;next/server&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { eq, isNull } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;drizzle-orm&quot;</span>;\n<span class=\"hljs-keyword\">import</span> summarizeArticle <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/ai/summarize&quot;</span>;\n<span class=\"hljs-keyword\">import</span> db <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/db&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { articles } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/db/schema&quot;</span>;\n<span class=\"hljs-keyword\">import</span> redis <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/cache&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">GET</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">req</span>: <span class=\"hljs-title class_\">NextRequest</span></span>) {\n  <span class=\"hljs-keyword\">if</span> (\n    process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">NODE_ENV</span> !== <span class=\"hljs-string\">&quot;development&quot;</span> &amp;&amp;\n    req.<span class=\"hljs-property\">headers</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;authorization&quot;</span>) !== <span class=\"hljs-string\">`Bearer <span class=\"hljs-subst\">${process.env.CRON_SECRET}</span>`</span>\n  ) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">NextResponse</span>.<span class=\"hljs-title function_\">json</span>({ <span class=\"hljs-attr\">error</span>: <span class=\"hljs-string\">&quot;Unauthorized&quot;</span> }, { <span class=\"hljs-attr\">status</span>: <span class=\"hljs-number\">401</span> });\n  }\n\n  <span class=\"hljs-comment\">// Find articles that don&#x27;t yet have a summary</span>\n  <span class=\"hljs-keyword\">const</span> rows = <span class=\"hljs-keyword\">await</span> db\n    .<span class=\"hljs-title function_\">select</span>({\n      <span class=\"hljs-attr\">id</span>: articles.<span class=\"hljs-property\">id</span>,\n      <span class=\"hljs-attr\">title</span>: articles.<span class=\"hljs-property\">title</span>,\n      <span class=\"hljs-attr\">content</span>: articles.<span class=\"hljs-property\">content</span>,\n    })\n    .<span class=\"hljs-title function_\">from</span>(articles)\n    .<span class=\"hljs-title function_\">where</span>(<span class=\"hljs-title function_\">isNull</span>(articles.<span class=\"hljs-property\">summary</span>));\n\n  <span class=\"hljs-keyword\">if</span> (!rows || rows.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">0</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">NextResponse</span>.<span class=\"hljs-title function_\">json</span>({ <span class=\"hljs-attr\">ok</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">updated</span>: <span class=\"hljs-number\">0</span> });\n  }\n\n  <span class=\"hljs-keyword\">let</span> updated = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;ü§ñ Starting AI summary job&quot;</span>);\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> row <span class=\"hljs-keyword\">of</span> rows) {\n    <span class=\"hljs-keyword\">try</span> {\n      <span class=\"hljs-keyword\">const</span> summary = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">summarizeArticle</span>(row.<span class=\"hljs-property\">title</span> ?? <span class=\"hljs-string\">&quot;&quot;</span>, row.<span class=\"hljs-property\">content</span>);\n\n      <span class=\"hljs-keyword\">if</span> (summary &amp;&amp; summary.<span class=\"hljs-title function_\">trim</span>().<span class=\"hljs-property\">length</span> &gt; <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-keyword\">await</span> db\n          .<span class=\"hljs-title function_\">update</span>(articles)\n          .<span class=\"hljs-title function_\">set</span>({ summary })\n          .<span class=\"hljs-title function_\">where</span>(<span class=\"hljs-title function_\">eq</span>(articles.<span class=\"hljs-property\">id</span>, row.<span class=\"hljs-property\">id</span>));\n        updated++;\n      }\n    } <span class=\"hljs-keyword\">catch</span> (err) {\n      <span class=\"hljs-comment\">// log and continue with next article</span>\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&quot;Failed to summarize article id=&quot;</span>, row.<span class=\"hljs-property\">id</span>, err);\n      <span class=\"hljs-keyword\">continue</span>;\n    }\n  }\n\n  <span class=\"hljs-keyword\">if</span> (updated &gt; <span class=\"hljs-number\">0</span>) {\n    <span class=\"hljs-comment\">// Clear articles cache used by getArticles</span>\n    <span class=\"hljs-keyword\">try</span> {\n      <span class=\"hljs-keyword\">await</span> redis.<span class=\"hljs-title function_\">del</span>(<span class=\"hljs-string\">&quot;articles:all&quot;</span>);\n    } <span class=\"hljs-keyword\">catch</span> (e) {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">warn</span>(<span class=\"hljs-string\">&quot;‚ö†Ô∏è Failed to clear articles cache&quot;</span>, e);\n    }\n  }\n\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`ü§ñ Concluding AI summary job, updated <span class=\"hljs-subst\">${updated}</span> rows`</span>);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">NextResponse</span>.<span class=\"hljs-title function_\">json</span>({ <span class=\"hljs-attr\">ok</span>: <span class=\"hljs-literal\">true</span>, updated });\n}\n</code></pre><ul>\n<li>It now works in dev so we can just hit <code>localhost:3000/api/summary</code> in a browser and it&#39;ll run</li>\n<li>In prod it&#39;ll check the CRON header and if it doesn&#39;t match it won&#39;t run.</li>\n<li>Beyond that, we&#39;re just reading from the DB and updating rows that don&#39;t have summaries</li>\n<li>We also clear cache if any of the articles get updated</li>\n</ul>\n<p>Make a new file called <code>vercel.json</code> and we&#39;ll have it run once a week.</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;crons&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span>\n    <span class=\"hljs-punctuation\">{</span>\n      <span class=\"hljs-attr\">&quot;path&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;/api/summary&quot;</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">&quot;schedule&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;0 0 * * 0&quot;</span>\n    <span class=\"hljs-punctuation\">}</span>\n  <span class=\"hljs-punctuation\">]</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre><p>This will run every Sunday at midnight UTC. Feel free to make it whenever you want. If you need help <a href=\"https://crontab.guru/#0_0_*_*_0\">cron.guru</a> is very helpful.</p>\n<p>And there you go! Now you can have AI summaries running once a week, and in general you now how to do jobs with Vercel and Next.js. This is nice but it applies only to Vercel. Generally speaking I&#39;ve usually done these sorts of jobs with serverless functions like Azure Functions or AWS Lambdas as those are easy to schedule.</p>\n<p>You also learned how to make API endpoints with Next.js. These days I think unless you&#39;re making endpoints available to outside users or mobile apps, it&#39;s a bit of an anti-pattern to make API endpoints as you should just be using React Server Components do all the connecting between clients and servers.</p>\n<p>Lastly we learned how to do migrations with Drizzle. While this is a pretty simple example of it, this is how you do it - just modify your schema files and let Drizzle handle the rest!</p>\n<blockquote>\n<p>üèÅ This is the <a href=\"https://github.com/btholt/fullstack-next-wiki/tree/main/08-ai\">08-ai</a> checkpoint. Open that folder in the sample project repo to go to where we are as of right here.</p>\n</blockquote>\n","markdown":"So, now we have a problem - we have some records that have AI summary records, and some that don't. Maybe we make those summary updates low priority, or maybe they fail on some normal interval. What can we do about that? We could make it check on reads but that slows down a critical path. What we could do better is schedule a job to run on some reoccurring basis, essentially a [cron job][cron].\n\nVercel has a very easy way to do cron jobs for Next.js apps. You just define an API function and Vercel will call the API function for you. Vercel will put in a special variable so you can make sure it's only Vercel that will call the function too (we don't want random people invoking our jobs.)\n\nLet's do it! Let's make a job that runs weekly to make sure that all items in the database have summaries.\n\n> Why weekly? Every time this runs it'll wake your Vercel and Neon instances, costing you money or free tier credit. I chose weekly because adding a few minutes week isn't too bad. If you ran this every minute you'd eat through both Vercel and Neon's free tiers.\n\nIn src/app, create a new folder, `api`. In the api directory, make a new directory, `summary`. In there, create a new file, `route.ts`.\n\nIn there put:\n\n```typescript\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { eq, isNull } from \"drizzle-orm\";\nimport summarizeArticle from \"@/ai/summarize\";\nimport db from \"@/db\";\nimport { articles } from \"@/db/schema\";\nimport redis from \"@/cache\";\n\nexport async function GET(req: NextRequest) {\n  if (\n    process.env.NODE_ENV !== \"development\" &&\n    req.headers.get(\"authorization\") !== `Bearer ${process.env.CRON_SECRET}`\n  ) {\n    return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n  }\n\n  // Find articles that don't yet have a summary\n  const rows = await db\n    .select({\n      id: articles.id,\n      title: articles.title,\n      content: articles.content,\n    })\n    .from(articles)\n    .where(isNull(articles.summary));\n\n  if (!rows || rows.length === 0) {\n    return NextResponse.json({ ok: true, updated: 0 });\n  }\n\n  let updated = 0;\n  console.log(\"ü§ñ Starting AI summary job\");\n\n  for (const row of rows) {\n    try {\n      const summary = await summarizeArticle(row.title ?? \"\", row.content);\n\n      if (summary && summary.trim().length > 0) {\n        await db\n          .update(articles)\n          .set({ summary })\n          .where(eq(articles.id, row.id));\n        updated++;\n      }\n    } catch (err) {\n      // log and continue with next article\n      console.error(\"Failed to summarize article id=\", row.id, err);\n      continue;\n    }\n  }\n\n  if (updated > 0) {\n    // Clear articles cache used by getArticles\n    try {\n      await redis.del(\"articles:all\");\n    } catch (e) {\n      console.warn(\"‚ö†Ô∏è Failed to clear articles cache\", e);\n    }\n  }\n\n  console.log(`ü§ñ Concluding AI summary job, updated ${updated} rows`);\n\n  return NextResponse.json({ ok: true, updated });\n}\n```\n\n- It now works in dev so we can just hit `localhost:3000/api/summary` in a browser and it'll run\n- In prod it'll check the CRON header and if it doesn't match it won't run.\n- Beyond that, we're just reading from the DB and updating rows that don't have summaries\n- We also clear cache if any of the articles get updated\n\nMake a new file called `vercel.json` and we'll have it run once a week.\n\n```json\n{\n  \"crons\": [\n    {\n      \"path\": \"/api/summary\",\n      \"schedule\": \"0 0 * * 0\"\n    }\n  ]\n}\n```\n\nThis will run every Sunday at midnight UTC. Feel free to make it whenever you want. If you need help [cron.guru][guru] is very helpful.\n\nAnd there you go! Now you can have AI summaries running once a week, and in general you now how to do jobs with Vercel and Next.js. This is nice but it applies only to Vercel. Generally speaking I've usually done these sorts of jobs with serverless functions like Azure Functions or AWS Lambdas as those are easy to schedule.\n\nYou also learned how to make API endpoints with Next.js. These days I think unless you're making endpoints available to outside users or mobile apps, it's a bit of an anti-pattern to make API endpoints as you should just be using React Server Components do all the connecting between clients and servers.\n\nLastly we learned how to do migrations with Drizzle. While this is a pretty simple example of it, this is how you do it - just modify your schema files and let Drizzle handle the rest!\n\n> üèÅ This is the [08-ai][checkpoint] checkpoint. Open that folder in the sample project repo to go to where we are as of right here.\n\n[checkpoint]: https://github.com/btholt/fullstack-next-wiki/tree/main/08-ai\n[cron]: https://btholt.github.io/complete-intro-to-linux-and-the-cli/cron\n[guru]: https://crontab.guru/#0_0_*_*_0\n","slug":"cron","title":"Cron","section":"AI","icon":"robot","filePath":"/home/runner/work/build-a-fullstack-nextjs-app-v4/build-a-fullstack-nextjs-app-v4/lessons/08-ai/C-cron.md","nextSlug":"/lessons/devops/deploy-to-vercel","prevSlug":"/lessons/ai/ai-inference"}},"__N_SSG":true}