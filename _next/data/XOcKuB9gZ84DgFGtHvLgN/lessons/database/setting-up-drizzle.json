{"pageProps":{"post":{"attributes":{},"html":"<p>We are going to get started writing to our database using Drizzle. Drizzle is a phenomenal ORM, which stands for object-relational mapping. In reality it just means a it&#39;s a software package where you define the shape of your data, and it takes care of managing and querying the database for you. Instead of writing raw SQL statements, you write code that then gets translated into SQL for you.</p>\n<p>In the past I did not recommend using an ORM (I think you can find this in my previous Frontend Masters courses!) Why not? I had some pretty bad experiences over the year using ORMs in the earlier days of my career (mostly in PHP and Java.) I&#39;d start using an ORM and it would be amazing: it made it easy to get started, to do basic selects and inserts, and the general 95% use case (and I&#39;ll say generally speaking, writing this sort of SQL is not hard.) The problem came when you needed to do more advanced querying that the designers of the ORM didn&#39;t anticipate. All the sudden what was helping you work faster was a huge impedance on you doing what you want to do. You&#39;re suddenly fighting the framework instead of being helped by it. This happened frequently enough that I decided I&#39;d rather just write SQL, and I did that for most of my career (I also like SQL, but it took a lot of practice for me to say that.)</p>\n<p>So why now? Why do I like Drizzle instead of choosing to just to continue to do raw SQL?</p>\n<ul>\n<li>Its design is very SQL-ish. A lot of other ORMs try to hide SQL from you and in the process make it hard when you need to do SQL-ish things. that&#39;s probably my biggest complaint about other ORMs and I <em>don&#39;t</em> have that about Drizzle.</li>\n<li>TypeScript support, and that&#39;s the biggest reason <em>to</em> use Drizzle. When you describe something in Drizzle, all the sudden you have amazing TypeScript support for all your database queries. Otherwise you&#39;d be stuck writing all these types yourself and with Drizzle you just don&#39;t have to.</li>\n<li>They even go one step further and they make little packages for each database provider. For Neon, we have all the Neon Auth tables built into the Drizzle package so you don&#39;t need to write those types; they&#39;re just built into Drizzle. So cool!</li>\n<li>The OSS team is also super nice and helpful.</li>\n</ul>\n<p>So let&#39;s get started! We&#39;re going to need a few packages</p>\n<pre><code class=\"hljs language-bash\">npm i drizzle-orm @neondatabase/serverless dotenv\nnpm i -D drizzle-kit drizzle-seed\n</code></pre><ul>\n<li>The ORM package is package that you&#39;ll actually use in your codebase.</li>\n<li>The drizzle-kit package is all the CLI commands you need to run Drizzle. So creating migrations, running migrations, etc.</li>\n<li>We could use the normal pg and postgres.js packages, and in many cases you might want to. These use TCP for their connections and support connection pooling that leave connections open which means lower-latency and generally faster connections. However initial connections for these sorts of packages take a while and really aren&#39;t a good fit for things like serverless environments where connections will be spinning up and spinning down frequently.</li>\n<li>We&#39;re going to use the Neon serverless driver. This allows us to do SQL over either HTTP or WebSockets (and we&#39;re going to do HTTP.) Honestly if we were going to scale up this project, we&#39;d probably want to do the TCP drivers as it might make more sense, but I usually get started with the serverless driver and switch when I see it being helpful. Both work really well.</li>\n<li>Doing Neon over HTTP is perfectly suited for Vercel&#39;s serverless architecture, but it does carry some performance overhead. If you&#39;re really performance sensitive or doing transactions is really important to you, we&#39;d need to re-architect this to happen over websockets. But we don&#39;t so this works!</li>\n<li>We&#39;re also install drizzle-seed which makes seeding your Drizzle database very easy.</li>\n</ul>\n<p>Okay, let&#39;s start making our database work. Normally you&#39;d need to go to Neon.com and create your project and get your DATABASE_URL and put that in your .env file, but we did that as part of setting up auth. So let&#39;s go ahead and start with our config.</p>\n<p>Go create in the root of the project drizzle.config.ts. Put in there</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;dotenv/config&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { defineConfig } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;drizzle-kit&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">defineConfig</span>({\n  <span class=\"hljs-attr\">out</span>: <span class=\"hljs-string\">&quot;./drizzle&quot;</span>,\n  <span class=\"hljs-attr\">schema</span>: <span class=\"hljs-string\">&quot;./src/db/schema.ts&quot;</span>,\n  <span class=\"hljs-attr\">dialect</span>: <span class=\"hljs-string\">&quot;postgresql&quot;</span>,\n  <span class=\"hljs-attr\">dbCredentials</span>: {\n    <span class=\"hljs-attr\">url</span>: process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">DATABASE_URL</span>!,\n  },\n});\n</code></pre><p>This is just some basic config for Drizzle, nothing of note.</p>\n<p>Now go create src/db as a folder. Put in there schema.ts</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">import</span> { pgTable, serial, text, timestamp, <span class=\"hljs-built_in\">boolean</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;drizzle-orm/pg-core&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { usersSync } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;drizzle-orm/neon&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> articles = <span class=\"hljs-title function_\">pgTable</span>(<span class=\"hljs-string\">&quot;articles&quot;</span>, {\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title function_\">serial</span>(<span class=\"hljs-string\">&quot;id&quot;</span>).<span class=\"hljs-title function_\">primaryKey</span>(),\n  <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title function_\">text</span>(<span class=\"hljs-string\">&quot;title&quot;</span>).<span class=\"hljs-title function_\">notNull</span>(),\n  <span class=\"hljs-attr\">slug</span>: <span class=\"hljs-title function_\">text</span>(<span class=\"hljs-string\">&quot;slug&quot;</span>).<span class=\"hljs-title function_\">notNull</span>().<span class=\"hljs-title function_\">unique</span>(),\n  <span class=\"hljs-attr\">content</span>: <span class=\"hljs-title function_\">text</span>(<span class=\"hljs-string\">&quot;content&quot;</span>).<span class=\"hljs-title function_\">notNull</span>(),\n  <span class=\"hljs-attr\">imageUrl</span>: <span class=\"hljs-title function_\">text</span>(<span class=\"hljs-string\">&quot;image_url&quot;</span>),\n  <span class=\"hljs-attr\">published</span>: <span class=\"hljs-title function_\">boolean</span>(<span class=\"hljs-string\">&quot;published&quot;</span>).<span class=\"hljs-title function_\">default</span>(<span class=\"hljs-literal\">false</span>).<span class=\"hljs-title function_\">notNull</span>(),\n  <span class=\"hljs-attr\">authorId</span>: <span class=\"hljs-title function_\">text</span>(<span class=\"hljs-string\">&quot;author_id&quot;</span>)\n    .<span class=\"hljs-title function_\">notNull</span>()\n    .<span class=\"hljs-title function_\">references</span>(<span class=\"hljs-function\">() =&gt;</span> usersSync.<span class=\"hljs-property\">id</span>),\n  <span class=\"hljs-attr\">createdAt</span>: <span class=\"hljs-title function_\">timestamp</span>(<span class=\"hljs-string\">&quot;created_at&quot;</span>, { <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&quot;string&quot;</span> }).<span class=\"hljs-title function_\">defaultNow</span>().<span class=\"hljs-title function_\">notNull</span>(),\n  <span class=\"hljs-attr\">updatedAt</span>: <span class=\"hljs-title function_\">timestamp</span>(<span class=\"hljs-string\">&quot;updated_at&quot;</span>, { <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&quot;string&quot;</span> }).<span class=\"hljs-title function_\">defaultNow</span>().<span class=\"hljs-title function_\">notNull</span>(),\n});\n\n<span class=\"hljs-keyword\">const</span> schema = { articles };\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> schema;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Article</span> = <span class=\"hljs-keyword\">typeof</span> articles.<span class=\"hljs-property\">$inferSelect</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">NewArticle</span> = <span class=\"hljs-keyword\">typeof</span> articles.<span class=\"hljs-property\">$inferInsert</span>;\n</code></pre><ul>\n<li>While this is a lot of new code for you, if you know SQL it should all look <em>super</em> familiar to you. We&#39;re basically doing <code>CREATE TABLE</code> commands in code. We&#39;re describing what data types we want and what constraints we want (like notNull or unique).</li>\n<li>usersSync from the neon portion of the drizzle-orm package describes the users table from Neon Auth. It&#39;s a table that already exists, and we already have all the types and such from Drizzle, made by the Neon and Drizzle team. Pretty cool that it already exists!</li>\n<li><code>references</code> sets up a foreign key. That means the authorId references the id key in the usersSync table.</li>\n<li>What&#39;s nice is we&#39;re not stuck calling &quot;created_at&quot; using snake case in JavaScript. Drizzle makes it easy for us to define our own alias of what we want to call it in code versus what it&#39;s called in the database. This was particularly helpful in a codebase I was working in where the actual names of the columns were very long and annoying due to being apart of another system but we could call it whatever we wanted in JS code.</li>\n<li><code>$inferSelect</code> and <code>$inferInsert</code> are probably two of the coolest black magic features in code I&#39;ve ever used. It takes the database shape that we set up for the articles tables and turns it into a TypeScript type. We write the code once and we get both the TypeScript types and the database ORM to use. Amazing. If you&#39;re writing raw SQL, you need to author and maintain those types yourself.</li>\n</ul>\n<p>That&#39;s it! Now we have a schema that we can use to create our database connection. Go create an index.ts file in the same directory.</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">import</span> { neon } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@neondatabase/serverless&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { drizzle } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;drizzle-orm/neon-http&quot;</span>;\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> schema <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/db/schema&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;dotenv/config&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> sql = <span class=\"hljs-title function_\">neon</span>(process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">DATABASE_URL</span>!);\n<span class=\"hljs-keyword\">const</span> db = <span class=\"hljs-title function_\">drizzle</span>(sql, { schema });\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> db;\n</code></pre><p>This is just setting up the ORM to be ready to be used by your code. If you were using the pg or postgres packages, you&#39;d set those up here instead. It&#39;s really easy to swap in the future - no other code needs to change.</p>\n<p>Okay, now let&#39;s create our first migration with generate.</p>\n<pre><code class=\"hljs language-bash\">npx drizzle-kit generate\n</code></pre><p>This actually creates the drizzle directory in the root of your project (check this code in) and spits out some meta data and raw SQL files. Feel free to read these (I like Drizzle because these are usually pretty readable) but never, ever, ever modify these by hands. You are setting yourself up for major issues if you do because Drizzle assumes it does all of these and will not respect any handcrafted code you chuck in here.</p>\n<blockquote>\n<p>Note that this creates the migrations but does not apply them. Your Neon database will still be empty until you run migrate.</p>\n</blockquote>\n<p>Now let&#39;s run it.</p>\n<pre><code class=\"hljs language-bash\">npx drizzle-kit migrate\n</code></pre><p>This applies what we made with generate. And now you can see the empty tables in Neon. Pretty cool, right!?</p>\n<blockquote>\n<p>You can also run <code>npx drizzle-kit push</code> to just yolo apply whatever schema you have at the moment. This is nice when you&#39;re making changes and you just want to apply the new schema and aren&#39;t ready to codify what you have as code.</p>\n</blockquote>\n<p>I wrote a little seed script for you to have some database. <strong>Note: you must have at least one user signed up via Neon Auth or this does not work</strong>. Either sign up via your website or add one manually via the Neon console.</p>\n<p><a href=\"https://github.com/btholt/fullstack-next-wiki/tree/main/04-database/src/db/seed.ts\">Copy and paste all of this code</a> into db/seed.ts.</p>\n<p>Let&#39;s make all of these npm scripts.</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-comment\">// the end of your scripts in your package.json</span>\n<span class=\"hljs-attr\">&quot;db:seed&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;tsx src/db/seed.ts&quot;</span><span class=\"hljs-punctuation\">,</span>\n<span class=\"hljs-attr\">&quot;db:generate&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;drizzle-kit generate&quot;</span><span class=\"hljs-punctuation\">,</span>\n<span class=\"hljs-attr\">&quot;db:migrate&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;drizzle-kit migrate&quot;</span>\n</code></pre><p>We&#39;ll need tsx for this as well (run TypeScript files as Node, just makes it easy) so run <code>npm i -D tsx</code></p>\n<p>So feel free to run <code>npm run db:seed</code> now and you should have five articles in your database now to play with.</p>\n<p>Awesome. Let&#39;s go <em>use</em> these now.</p>\n","markdown":"We are going to get started writing to our database using Drizzle. Drizzle is a phenomenal ORM, which stands for object-relational mapping. In reality it just means a it's a software package where you define the shape of your data, and it takes care of managing and querying the database for you. Instead of writing raw SQL statements, you write code that then gets translated into SQL for you.\n\nIn the past I did not recommend using an ORM (I think you can find this in my previous Frontend Masters courses!) Why not? I had some pretty bad experiences over the year using ORMs in the earlier days of my career (mostly in PHP and Java.) I'd start using an ORM and it would be amazing: it made it easy to get started, to do basic selects and inserts, and the general 95% use case (and I'll say generally speaking, writing this sort of SQL is not hard.) The problem came when you needed to do more advanced querying that the designers of the ORM didn't anticipate. All the sudden what was helping you work faster was a huge impedance on you doing what you want to do. You're suddenly fighting the framework instead of being helped by it. This happened frequently enough that I decided I'd rather just write SQL, and I did that for most of my career (I also like SQL, but it took a lot of practice for me to say that.)\n\nSo why now? Why do I like Drizzle instead of choosing to just to continue to do raw SQL?\n\n- Its design is very SQL-ish. A lot of other ORMs try to hide SQL from you and in the process make it hard when you need to do SQL-ish things. that's probably my biggest complaint about other ORMs and I _don't_ have that about Drizzle.\n- TypeScript support, and that's the biggest reason _to_ use Drizzle. When you describe something in Drizzle, all the sudden you have amazing TypeScript support for all your database queries. Otherwise you'd be stuck writing all these types yourself and with Drizzle you just don't have to.\n- They even go one step further and they make little packages for each database provider. For Neon, we have all the Neon Auth tables built into the Drizzle package so you don't need to write those types; they're just built into Drizzle. So cool!\n- The OSS team is also super nice and helpful.\n\nSo let's get started! We're going to need a few packages\n\n```bash\nnpm i drizzle-orm @neondatabase/serverless dotenv\nnpm i -D drizzle-kit drizzle-seed\n```\n\n- The ORM package is package that you'll actually use in your codebase.\n- The drizzle-kit package is all the CLI commands you need to run Drizzle. So creating migrations, running migrations, etc.\n- We could use the normal pg and postgres.js packages, and in many cases you might want to. These use TCP for their connections and support connection pooling that leave connections open which means lower-latency and generally faster connections. However initial connections for these sorts of packages take a while and really aren't a good fit for things like serverless environments where connections will be spinning up and spinning down frequently.\n- We're going to use the Neon serverless driver. This allows us to do SQL over either HTTP or WebSockets (and we're going to do HTTP.) Honestly if we were going to scale up this project, we'd probably want to do the TCP drivers as it might make more sense, but I usually get started with the serverless driver and switch when I see it being helpful. Both work really well.\n- Doing Neon over HTTP is perfectly suited for Vercel's serverless architecture, but it does carry some performance overhead. If you're really performance sensitive or doing transactions is really important to you, we'd need to re-architect this to happen over websockets. But we don't so this works!\n- We're also install drizzle-seed which makes seeding your Drizzle database very easy.\n\nOkay, let's start making our database work. Normally you'd need to go to Neon.com and create your project and get your DATABASE_URL and put that in your .env file, but we did that as part of setting up auth. So let's go ahead and start with our config.\n\nGo create in the root of the project drizzle.config.ts. Put in there\n\n```typescript\nimport \"dotenv/config\";\nimport { defineConfig } from \"drizzle-kit\";\n\nexport default defineConfig({\n  out: \"./drizzle\",\n  schema: \"./src/db/schema.ts\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n});\n```\n\nThis is just some basic config for Drizzle, nothing of note.\n\nNow go create src/db as a folder. Put in there schema.ts\n\n```typescript\nimport { pgTable, serial, text, timestamp, boolean } from \"drizzle-orm/pg-core\";\nimport { usersSync } from \"drizzle-orm/neon\";\n\nexport const articles = pgTable(\"articles\", {\n  id: serial(\"id\").primaryKey(),\n  title: text(\"title\").notNull(),\n  slug: text(\"slug\").notNull().unique(),\n  content: text(\"content\").notNull(),\n  imageUrl: text(\"image_url\"),\n  published: boolean(\"published\").default(false).notNull(),\n  authorId: text(\"author_id\")\n    .notNull()\n    .references(() => usersSync.id),\n  createdAt: timestamp(\"created_at\", { mode: \"string\" }).defaultNow().notNull(),\n  updatedAt: timestamp(\"updated_at\", { mode: \"string\" }).defaultNow().notNull(),\n});\n\nconst schema = { articles };\nexport default schema;\n\nexport type Article = typeof articles.$inferSelect;\nexport type NewArticle = typeof articles.$inferInsert;\n```\n\n- While this is a lot of new code for you, if you know SQL it should all look _super_ familiar to you. We're basically doing `CREATE TABLE` commands in code. We're describing what data types we want and what constraints we want (like notNull or unique).\n- usersSync from the neon portion of the drizzle-orm package describes the users table from Neon Auth. It's a table that already exists, and we already have all the types and such from Drizzle, made by the Neon and Drizzle team. Pretty cool that it already exists!\n- `references` sets up a foreign key. That means the authorId references the id key in the usersSync table.\n- What's nice is we're not stuck calling \"created_at\" using snake case in JavaScript. Drizzle makes it easy for us to define our own alias of what we want to call it in code versus what it's called in the database. This was particularly helpful in a codebase I was working in where the actual names of the columns were very long and annoying due to being apart of another system but we could call it whatever we wanted in JS code.\n- `$inferSelect` and `$inferInsert` are probably two of the coolest black magic features in code I've ever used. It takes the database shape that we set up for the articles tables and turns it into a TypeScript type. We write the code once and we get both the TypeScript types and the database ORM to use. Amazing. If you're writing raw SQL, you need to author and maintain those types yourself.\n\nThat's it! Now we have a schema that we can use to create our database connection. Go create an index.ts file in the same directory.\n\n```typescript\nimport { neon } from \"@neondatabase/serverless\";\nimport { drizzle } from \"drizzle-orm/neon-http\";\nimport * as schema from \"@/db/schema\";\nimport \"dotenv/config\";\n\nconst sql = neon(process.env.DATABASE_URL!);\nconst db = drizzle(sql, { schema });\n\nexport default db;\n```\n\nThis is just setting up the ORM to be ready to be used by your code. If you were using the pg or postgres packages, you'd set those up here instead. It's really easy to swap in the future - no other code needs to change.\n\nOkay, now let's create our first migration with generate.\n\n```bash\nnpx drizzle-kit generate\n```\n\nThis actually creates the drizzle directory in the root of your project (check this code in) and spits out some meta data and raw SQL files. Feel free to read these (I like Drizzle because these are usually pretty readable) but never, ever, ever modify these by hands. You are setting yourself up for major issues if you do because Drizzle assumes it does all of these and will not respect any handcrafted code you chuck in here.\n\n> Note that this creates the migrations but does not apply them. Your Neon database will still be empty until you run migrate.\n\nNow let's run it.\n\n```bash\nnpx drizzle-kit migrate\n```\n\nThis applies what we made with generate. And now you can see the empty tables in Neon. Pretty cool, right!?\n\n> You can also run `npx drizzle-kit push` to just yolo apply whatever schema you have at the moment. This is nice when you're making changes and you just want to apply the new schema and aren't ready to codify what you have as code.\n\nI wrote a little seed script for you to have some database. **Note: you must have at least one user signed up via Neon Auth or this does not work**. Either sign up via your website or add one manually via the Neon console.\n\n[Copy and paste all of this code][seed] into db/seed.ts.\n\nLet's make all of these npm scripts.\n\n```json\n// the end of your scripts in your package.json\n\"db:seed\": \"tsx src/db/seed.ts\",\n\"db:generate\": \"drizzle-kit generate\",\n\"db:migrate\": \"drizzle-kit migrate\"\n```\n\nWe'll need tsx for this as well (run TypeScript files as Node, just makes it easy) so run `npm i -D tsx`\n\nSo feel free to run `npm run db:seed` now and you should have five articles in your database now to play with.\n\nAwesome. Let's go _use_ these now.\n\n[seed]: https://github.com/btholt/fullstack-next-wiki/tree/main/04-database/src/db/seed.ts\n","slug":"setting-up-drizzle","title":"Setting up Drizzle","section":"Database","icon":"database","filePath":"/home/runner/work/build-a-fullstack-nextjs-app-v4/build-a-fullstack-nextjs-app-v4/lessons/04-database/B-setting-up-drizzle.md","nextSlug":"/lessons/database/query-with-drizzle","prevSlug":"/lessons/database/neon-and-postgres"}},"__N_SSG":true}