{"pageProps":{"post":{"attributes":{},"html":"<p>Now that we have both Neon Auth and the database, we can implement authorization (often abbreviated as authZ vs authN which is short for authentication).</p>\n<p>Because it confuses a lot of people, let&#39;s quickly disambiguate the two. Authentication is logging in, logging out, and signing up. It&#39;s you handshaking to the service &quot;this is who I am&quot; via social login, username-and-password, etc. Authentication answers the question <strong>who is it</strong>? Authorization is taking your identity and asking the question <strong>what are you allowed to do?</strong> I can be logged in to Facebook but I can&#39;t see everyone&#39;s DMs. Why? Because I am not authorized to do so. However you are authorized to see your own DMs. And possibly the admins / moderators of Facebook can see them too, because they may be authorized to see <em>anyone</em>&#39;s DMs.</p>\n<p>We already did authentication when we implemented Stack Auth. But we haven&#39;t done anything with authorization. We just said &quot;if you&#39;re logged in you&#39;re authorized to do anything&quot;. Let&#39;s go make it so you can only edit your own posts.</p>\n<blockquote>\n<p>You&#39;ll see authZ and authN everywhere. Generally speaking when people write &quot;Auth&quot; they mean either just authN or both authZ and authN.</p>\n</blockquote>\n<p>Go to the db folder and create a file called authz.ts and put this in there</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">import</span> { eq } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;drizzle-orm&quot;</span>;\n<span class=\"hljs-keyword\">import</span> db <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/db/index&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { articles } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/db/schema&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> authorizeUserToEditArticle = <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">authorizeArticle</span>(<span class=\"hljs-params\">\n  <span class=\"hljs-attr\">loggedInUserId</span>: <span class=\"hljs-built_in\">string</span>,\n  <span class=\"hljs-attr\">articleId</span>: <span class=\"hljs-built_in\">number</span>\n</span>): <span class=\"hljs-title class_\">Promise</span>&lt;<span class=\"hljs-built_in\">boolean</span>&gt; {\n  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> db\n    .<span class=\"hljs-title function_\">select</span>({\n      <span class=\"hljs-attr\">authorId</span>: articles.<span class=\"hljs-property\">authorId</span>,\n    })\n    .<span class=\"hljs-title function_\">from</span>(articles)\n    .<span class=\"hljs-title function_\">where</span>(<span class=\"hljs-title function_\">eq</span>(articles.<span class=\"hljs-property\">id</span>, articleId));\n\n  <span class=\"hljs-keyword\">if</span> (!response.<span class=\"hljs-property\">length</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n  }\n\n  <span class=\"hljs-keyword\">return</span> response[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">authorId</span> === loggedInUserId;\n};\n</code></pre><p>This takes in an article ID and a user ID and returns if they are able to edit that article or not. Then we can reuse this helper in several places. Later, if we ant to add an editor role that can edit anything, we could just add it here and have it work everywhere. That&#39;s the idea.</p>\n<p>There&#39;s two ways I could have written this. I chose to write the authZ part in TypeScript, <code>response[0].authorId === loggedInUserId</code>. We could have written this as SQL, <code>and(eq(articles.id, articleId), eq(articles.authorId, loggedInUserId))</code> and let the database done the checking instead of us in TypeScript. Inevitably someone will take exception to the fact this was written this way, so let me explain myself.</p>\n<ul>\n<li>Letting the database do it will be ever-so-slightly more performant, probably, which is why some people were prefer that way. You may need to add an index to accomplish that, but that&#39;s not really a big enough deal for that to be a reason to not do it.</li>\n<li>I like doing it in code because I find the code more readable, and the performance hit is so minimal that I choose to value what I find more readable over what could save a millisecond.</li>\n<li>Doing it in code would make it easier to refactor later to add other authZ logic here.</li>\n</ul>\n<p>Okay, we have authZ logic, now go back to your articles.ts in your actions directory and let&#39;s implement it there</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// at top</span>\n<span class=\"hljs-keyword\">import</span> { authorizeUserToEditArticle } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/db/authz&quot;</span>;\n\n<span class=\"hljs-comment\">// put after authorized check in delete and update function</span>\n<span class=\"hljs-keyword\">if</span> (!(<span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">authorizeUserToEditArticle</span>(user.<span class=\"hljs-property\">id</span>, +id))) {\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&quot;‚ùå Forbidden&quot;</span>);\n}\n</code></pre><p>That&#39;s it!</p>\n<p>What about error handling? There&#39;s a couple ways of handling errors with server actions and I find this to be the most straightforward: just throw an error and catch it on the client. This isn&#39;t like a normal API with status codes and such - with a server action there&#39;s no public reusable API, just really remote code execution. You could also return status codes in the replies if you want to mimic that aspect of API calls, but that point you may almost just be better off making real APIs. The point of server actions to have them feel more like code than remote API invocations.</p>\n<blockquote>\n<p>üèÅ This is the <a href=\"https://github.com/btholt/fullstack-next-wiki/tree/main/04-database\">04-database</a> checkpoint. Open that folder in the sample project repo to go to where we are as of right here.</p>\n</blockquote>\n","markdown":"Now that we have both Neon Auth and the database, we can implement authorization (often abbreviated as authZ vs authN which is short for authentication).\n\nBecause it confuses a lot of people, let's quickly disambiguate the two. Authentication is logging in, logging out, and signing up. It's you handshaking to the service \"this is who I am\" via social login, username-and-password, etc. Authentication answers the question **who is it**? Authorization is taking your identity and asking the question **what are you allowed to do?** I can be logged in to Facebook but I can't see everyone's DMs. Why? Because I am not authorized to do so. However you are authorized to see your own DMs. And possibly the admins / moderators of Facebook can see them too, because they may be authorized to see _anyone_'s DMs.\n\nWe already did authentication when we implemented Stack Auth. But we haven't done anything with authorization. We just said \"if you're logged in you're authorized to do anything\". Let's go make it so you can only edit your own posts.\n\n> You'll see authZ and authN everywhere. Generally speaking when people write \"Auth\" they mean either just authN or both authZ and authN.\n\nGo to the db folder and create a file called authz.ts and put this in there\n\n```typescript\nimport { eq } from \"drizzle-orm\";\nimport db from \"@/db/index\";\nimport { articles } from \"@/db/schema\";\n\nexport const authorizeUserToEditArticle = async function authorizeArticle(\n  loggedInUserId: string,\n  articleId: number\n): Promise<boolean> {\n  const response = await db\n    .select({\n      authorId: articles.authorId,\n    })\n    .from(articles)\n    .where(eq(articles.id, articleId));\n\n  if (!response.length) {\n    return false;\n  }\n\n  return response[0].authorId === loggedInUserId;\n};\n```\n\nThis takes in an article ID and a user ID and returns if they are able to edit that article or not. Then we can reuse this helper in several places. Later, if we ant to add an editor role that can edit anything, we could just add it here and have it work everywhere. That's the idea.\n\nThere's two ways I could have written this. I chose to write the authZ part in TypeScript, `response[0].authorId === loggedInUserId`. We could have written this as SQL, `and(eq(articles.id, articleId), eq(articles.authorId, loggedInUserId))` and let the database done the checking instead of us in TypeScript. Inevitably someone will take exception to the fact this was written this way, so let me explain myself.\n\n- Letting the database do it will be ever-so-slightly more performant, probably, which is why some people were prefer that way. You may need to add an index to accomplish that, but that's not really a big enough deal for that to be a reason to not do it.\n- I like doing it in code because I find the code more readable, and the performance hit is so minimal that I choose to value what I find more readable over what could save a millisecond.\n- Doing it in code would make it easier to refactor later to add other authZ logic here.\n\nOkay, we have authZ logic, now go back to your articles.ts in your actions directory and let's implement it there\n\n```typescript\n// at top\nimport { authorizeUserToEditArticle } from \"@/db/authz\";\n\n// put after authorized check in delete and update function\nif (!(await authorizeUserToEditArticle(user.id, +id))) {\n  throw new Error(\"‚ùå Forbidden\");\n}\n```\n\nThat's it!\n\nWhat about error handling? There's a couple ways of handling errors with server actions and I find this to be the most straightforward: just throw an error and catch it on the client. This isn't like a normal API with status codes and such - with a server action there's no public reusable API, just really remote code execution. You could also return status codes in the replies if you want to mimic that aspect of API calls, but that point you may almost just be better off making real APIs. The point of server actions to have them feel more like code than remote API invocations.\n\n> üèÅ This is the [04-database][checkpoint] checkpoint. Open that folder in the sample project repo to go to where we are as of right here.\n\n[checkpoint]: https://github.com/btholt/fullstack-next-wiki/tree/main/04-database\n","slug":"authorization","title":"Authorization","section":"Database","icon":"database","filePath":"/home/runner/work/build-a-fullstack-nextjs-app-v4/build-a-fullstack-nextjs-app-v4/lessons/04-database/E-authorization.md","nextSlug":"/lessons/object-storage/vercel-blob","prevSlug":"/lessons/database/writes-with-drizzle"}},"__N_SSG":true}