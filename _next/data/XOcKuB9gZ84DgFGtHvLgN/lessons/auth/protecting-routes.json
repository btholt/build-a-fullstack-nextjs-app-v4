{"pageProps":{"post":{"attributes":{},"html":"<p>We need to protect our edit page. Right now any anonymous user can load that page which is not what we want - if you are logged out, we want you to log in first before we let you edit.</p>\n<blockquote>\n<p>We haven&#39;t set up the database yet so we&#39;ll only just be differentiating between logged in and logged out. We&#39;ll revisit when we add the database to restrict edits to your articles only or allow admins to edit any article.</p>\n</blockquote>\n<p>There are three ways to protect a route with Stack Auth (and I&#39;d say it&#39;s pretty generally true for all of Next.js): client-side, server-side, or middleware.</p>\n<h2>Client Side</h2>\n<p>A client-side redirect will look like <code>useUser({ or: &#39;redirect&#39; });</code>. This tells Next.js &quot;hey, if there&#39;s no user here, just redirect them to log in&quot;. You can also redirect them anywhere, but this is the most common thing you&#39;d do. This works just fine in many cases and is a good user experience as the client can immediately redirect a user without a roundtrip to the server.</p>\n<p>What&#39;s wrong with client side redirects? The code for these pages is all still sent to the browser, regardless if a user can access it or not. If the page contains sensitive data or shows off hidden endpoints that you may not want to leak or anything that truly is sensitive, you don&#39;t want to do this as any attacker could load up your JS and find whatever info you were trying to protect.</p>\n<p>In our case it&#39;s totally fine - we&#39;re not trying to hide the editor from anyone, we just don&#39;t don&#39;t want to show to anyone who wouldn&#39;t be able to use it. We can absolutely use a client side redirect here.</p>\n<h2>Server Side</h2>\n<p>Likewise a server side redirect will look like <code>await stackServerApp.getUser({ or: &#39;redirect&#39; });</code>. This will make sure it all happens on the server and anything inside the component can be guaranteed not to be sent to the user unless they pass the login test. You&#39;ll find yourself doing this for React Server Components.</p>\n<p>Something similar will likely also be done for API routes should you choose to implement those. In that case you&#39;ll do <code>await stackServerApp.getUser()</code> and then do a Next.js redirect if the user object doesn&#39;t exist.</p>\n<p>Again, it&#39;s important to note, all of these are plenty secure - no one is going to be able to impersonate someone else, but it&#39;s just a matter if you care that the components are being sent down and not used for a user that doesn&#39;t pass the authorization.</p>\n<h2>Middleware</h2>\n<p>The code for this will look like</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// from the stack auth docs</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">middleware</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">request</span>: <span class=\"hljs-title class_\">NextRequest</span></span>) {\n  <span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-keyword\">await</span> stackServerApp.<span class=\"hljs-title function_\">getUser</span>();\n  <span class=\"hljs-keyword\">if</span> (!user) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">NextResponse</span>.<span class=\"hljs-title function_\">redirect</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">URL</span>(<span class=\"hljs-string\">&quot;/handler/sign-in&quot;</span>, request.<span class=\"hljs-property\">url</span>));\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">NextResponse</span>.<span class=\"hljs-title function_\">next</span>();\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> config = {\n  <span class=\"hljs-comment\">// You can add your own route protection logic here</span>\n  <span class=\"hljs-comment\">// Make sure not to protect the root URL, as it would prevent users from accessing static Next.js files or Stack&#x27;s /handler path</span>\n  <span class=\"hljs-attr\">matcher</span>: <span class=\"hljs-string\">&quot;/protected/:path*&quot;</span>,\n};\n</code></pre><p>This is what you&#39;d do if you wanted to protect a whole block of routes. In the case of the example code above, you&#39;d be gating access to <code>/protected/&lt;anything&gt;</code> so you wouldn&#39;t have to do it on each page. We won&#39;t do this today, but I wanted to let you know you don&#39;t have to do it page-by-page, you can do it in blocks too with middleware.</p>\n<p>So let&#39;s go do it for our app!</p>\n<p>In <code>/src/app/wiki/edit/[id]/page.tsx</code> put this</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// at top</span>\n<span class=\"hljs-keyword\">import</span> { stackServerApp } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/stack/server&quot;</span>;\n\n<span class=\"hljs-comment\">// under pulling the id out of params</span>\n<span class=\"hljs-keyword\">await</span> stackServerApp.<span class=\"hljs-title function_\">getUser</span>({ <span class=\"hljs-attr\">or</span>: <span class=\"hljs-string\">&quot;redirect&quot;</span> });\n\n<span class=\"hljs-comment\">// we&#x27;ll uncomment this later when the articles have real IDs</span>\n<span class=\"hljs-comment\">// if (user.id !== id) {</span>\n<span class=\"hljs-comment\">//   stackServerApp.redirectToHome();</span>\n<span class=\"hljs-comment\">// }</span>\n</code></pre><p>This lets us either get the user object back from Stack Auth or, if it doesn&#39;t exist because they aren&#39;t logged in, redirects them to sign in or sign up. We put in the commented code because we can&#39;t yet check that because the articles don&#39;t have valid IDs, but when they do it will just send the user to the home page. In theory we should probably have a Forbidden page, but for now this is fine.</p>\n<p>Okay, let&#39;s go do the new/page.tsx too</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// at top</span>\n<span class=\"hljs-keyword\">import</span> { stackServerApp } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/stack/server&quot;</span>;\n\n<span class=\"hljs-comment\">// replace function, add async</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">NewArticlePage</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">await</span> stackServerApp.<span class=\"hljs-title function_\">getUser</span>({ <span class=\"hljs-attr\">or</span>: <span class=\"hljs-string\">&quot;redirect&quot;</span> });\n    ...\n}\n</code></pre><p>The same! And there you go, we&#39;ve protected our pages with server-side redirects! We did server-side because our pages were already React Server Components and there was no reason to convert them; client-side would have been just fine.</p>\n<h2>Server Actions</h2>\n<p>We have some server actions to accept new and edited articles as well as image uploads. Just because those are server actions does not mean we can leave them unprotected. In reality they&#39;re just API endpoints too, even if they&#39;re not exposed as restful endpoints. Let&#39;s go protect those too (as it works mostly the same way too.)</p>\n<p>For <strong>both actions/upload.ts and actions/articles.ts</strong> do the following</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// add import to the top</span>\n<span class=\"hljs-keyword\">import</span> { stackServerApp } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/stack/server&quot;</span>;\n\n<span class=\"hljs-comment\">// add this to the top of every action function</span>\n<span class=\"hljs-keyword\">const</span> user = stackServerApp.<span class=\"hljs-title function_\">getUser</span>();\n<span class=\"hljs-keyword\">if</span> (!user) {\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&quot;‚ùå Unauthorized&quot;</span>);\n}\n</code></pre><p>This still only checks that the user has logged in - we&#39;re still letting any user edit any article, but we&#39;ll get there soon. But that is auth! Congrats!</p>\n<blockquote>\n<p>üèÅ This is the <a href=\"https://github.com/btholt/fullstack-next-wiki/tree/main/03-auth\">03-auth</a> checkpoint. Open that folder in the sample project repo to go to where we are as of right here.</p>\n</blockquote>\n","markdown":"We need to protect our edit page. Right now any anonymous user can load that page which is not what we want - if you are logged out, we want you to log in first before we let you edit.\n\n> We haven't set up the database yet so we'll only just be differentiating between logged in and logged out. We'll revisit when we add the database to restrict edits to your articles only or allow admins to edit any article.\n\nThere are three ways to protect a route with Stack Auth (and I'd say it's pretty generally true for all of Next.js): client-side, server-side, or middleware.\n\n## Client Side\n\nA client-side redirect will look like `useUser({ or: 'redirect' });`. This tells Next.js \"hey, if there's no user here, just redirect them to log in\". You can also redirect them anywhere, but this is the most common thing you'd do. This works just fine in many cases and is a good user experience as the client can immediately redirect a user without a roundtrip to the server.\n\nWhat's wrong with client side redirects? The code for these pages is all still sent to the browser, regardless if a user can access it or not. If the page contains sensitive data or shows off hidden endpoints that you may not want to leak or anything that truly is sensitive, you don't want to do this as any attacker could load up your JS and find whatever info you were trying to protect.\n\nIn our case it's totally fine - we're not trying to hide the editor from anyone, we just don't don't want to show to anyone who wouldn't be able to use it. We can absolutely use a client side redirect here.\n\n## Server Side\n\nLikewise a server side redirect will look like `await stackServerApp.getUser({ or: 'redirect' });`. This will make sure it all happens on the server and anything inside the component can be guaranteed not to be sent to the user unless they pass the login test. You'll find yourself doing this for React Server Components.\n\nSomething similar will likely also be done for API routes should you choose to implement those. In that case you'll do `await stackServerApp.getUser()` and then do a Next.js redirect if the user object doesn't exist.\n\nAgain, it's important to note, all of these are plenty secure - no one is going to be able to impersonate someone else, but it's just a matter if you care that the components are being sent down and not used for a user that doesn't pass the authorization.\n\n## Middleware\n\nThe code for this will look like\n\n```typescript\n// from the stack auth docs\nexport async function middleware(request: NextRequest) {\n  const user = await stackServerApp.getUser();\n  if (!user) {\n    return NextResponse.redirect(new URL(\"/handler/sign-in\", request.url));\n  }\n  return NextResponse.next();\n}\n\nexport const config = {\n  // You can add your own route protection logic here\n  // Make sure not to protect the root URL, as it would prevent users from accessing static Next.js files or Stack's /handler path\n  matcher: \"/protected/:path*\",\n};\n```\n\nThis is what you'd do if you wanted to protect a whole block of routes. In the case of the example code above, you'd be gating access to `/protected/<anything>` so you wouldn't have to do it on each page. We won't do this today, but I wanted to let you know you don't have to do it page-by-page, you can do it in blocks too with middleware.\n\nSo let's go do it for our app!\n\nIn `/src/app/wiki/edit/[id]/page.tsx` put this\n\n```typescript\n// at top\nimport { stackServerApp } from \"@/stack/server\";\n\n// under pulling the id out of params\nawait stackServerApp.getUser({ or: \"redirect\" });\n\n// we'll uncomment this later when the articles have real IDs\n// if (user.id !== id) {\n//   stackServerApp.redirectToHome();\n// }\n```\n\nThis lets us either get the user object back from Stack Auth or, if it doesn't exist because they aren't logged in, redirects them to sign in or sign up. We put in the commented code because we can't yet check that because the articles don't have valid IDs, but when they do it will just send the user to the home page. In theory we should probably have a Forbidden page, but for now this is fine.\n\nOkay, let's go do the new/page.tsx too\n\n```typescript\n// at top\nimport { stackServerApp } from \"@/stack/server\";\n\n// replace function, add async\nexport default async function NewArticlePage() {\n    await stackServerApp.getUser({ or: \"redirect\" });\n    ...\n}\n```\n\nThe same! And there you go, we've protected our pages with server-side redirects! We did server-side because our pages were already React Server Components and there was no reason to convert them; client-side would have been just fine.\n\n## Server Actions\n\nWe have some server actions to accept new and edited articles as well as image uploads. Just because those are server actions does not mean we can leave them unprotected. In reality they're just API endpoints too, even if they're not exposed as restful endpoints. Let's go protect those too (as it works mostly the same way too.)\n\nFor **both actions/upload.ts and actions/articles.ts** do the following\n\n```typescript\n// add import to the top\nimport { stackServerApp } from \"@/stack/server\";\n\n// add this to the top of every action function\nconst user = stackServerApp.getUser();\nif (!user) {\n  throw new Error(\"‚ùå Unauthorized\");\n}\n```\n\nThis still only checks that the user has logged in - we're still letting any user edit any article, but we'll get there soon. But that is auth! Congrats!\n\n> üèÅ This is the [03-auth][checkpoint] checkpoint. Open that folder in the sample project repo to go to where we are as of right here.\n\n[checkpoint]: https://github.com/btholt/fullstack-next-wiki/tree/main/03-auth\n","slug":"protecting-routes","title":"Protecting Routes","section":"Auth","icon":"user-lock","filePath":"/home/runner/work/build-a-fullstack-nextjs-app-v4/build-a-fullstack-nextjs-app-v4/lessons/03-auth/B-protecting-routes.md","nextSlug":"/lessons/database/neon-and-postgres","prevSlug":"/lessons/auth/signin-and-signup"}},"__N_SSG":true}