{"pageProps":{"post":{"attributes":{},"html":"<p>Let&#39;s start by doing the SELECTS first. Our app is already pulling dummy data via a server helper function, so this makes it pretty simple as we only need to update this server helper as opposed to doing it in the code (and makes it super testable!)</p>\n<p>Let&#39;s open src/lib/data/articles.ts.</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// replace everything but the getArticlesById function - we&#x27;ll do that in a sec</span>\n<span class=\"hljs-keyword\">import</span> db <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/db/index&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { articles } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/db/schema&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { eq } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;drizzle-orm&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { usersSync } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/db/schema&quot;</span>; <span class=\"hljs-comment\">// &lt;- this is different from the video - it&#x27;s the new path, or it can be combined with the above import</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getArticles</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> db\n    .<span class=\"hljs-title function_\">select</span>({\n      <span class=\"hljs-attr\">title</span>: articles.<span class=\"hljs-property\">title</span>,\n      <span class=\"hljs-attr\">id</span>: articles.<span class=\"hljs-property\">id</span>,\n      <span class=\"hljs-attr\">createdAt</span>: articles.<span class=\"hljs-property\">createdAt</span>,\n      <span class=\"hljs-attr\">content</span>: articles.<span class=\"hljs-property\">content</span>,\n      <span class=\"hljs-attr\">author</span>: usersSync.<span class=\"hljs-property\">name</span>,\n    })\n    .<span class=\"hljs-title function_\">from</span>(articles)\n    .<span class=\"hljs-title function_\">leftJoin</span>(usersSync, <span class=\"hljs-title function_\">eq</span>(articles.<span class=\"hljs-property\">authorId</span>, usersSync.<span class=\"hljs-property\">id</span>));\n  <span class=\"hljs-keyword\">return</span> response;\n}\n</code></pre><ul>\n<li>We&#39;re first importing our db client. This is what will actually connect to the database.</li>\n<li>We then import the articles schema. Why? This is how you reference which table you want to query. We want the articles table, so we import that schema.</li>\n<li>In the function, we run a select, choose what columns we want, tell it which table it&#39;s coming from, and then join in the author&#39;s name (because we want to say the article was written by Bob, not &quot;user-12334&quot;)</li>\n<li>We added the where clause and used <code>eq</code> which, as you may imagine, checks for equality. Here we&#39;re saying we want to do the join on where the authorId in the article table is the same as the usersSync id so we can get a name instead of an ID.</li>\n<li>And then we return the array of rows! That&#39;s it!</li>\n<li>This does not paginate. But it&#39;s very easy to do with either <a href=\"https://orm.drizzle.team/docs/guides/cursor-based-pagination\">cursors</a> or just using limit() and offset like normal SQL. Feel free to implement this yourself!</li>\n</ul>\n<p>This should make articles on the home page pull from the database! Hooray! Let&#39;s make the articles page pull from it too.</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getArticleById</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">id</span>: <span class=\"hljs-built_in\">number</span></span>) {\n  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> db\n    .<span class=\"hljs-title function_\">select</span>({\n      <span class=\"hljs-attr\">title</span>: articles.<span class=\"hljs-property\">title</span>,\n      <span class=\"hljs-attr\">id</span>: articles.<span class=\"hljs-property\">id</span>,\n      <span class=\"hljs-attr\">createdAt</span>: articles.<span class=\"hljs-property\">createdAt</span>,\n      <span class=\"hljs-attr\">content</span>: articles.<span class=\"hljs-property\">content</span>,\n      <span class=\"hljs-attr\">author</span>: usersSync.<span class=\"hljs-property\">name</span>,\n      <span class=\"hljs-attr\">imageUrl</span>: articles.<span class=\"hljs-property\">imageUrl</span>,\n    })\n    .<span class=\"hljs-title function_\">from</span>(articles)\n    .<span class=\"hljs-title function_\">where</span>(<span class=\"hljs-title function_\">eq</span>(articles.<span class=\"hljs-property\">id</span>, id))\n    .<span class=\"hljs-title function_\">leftJoin</span>(usersSync, <span class=\"hljs-title function_\">eq</span>(articles.<span class=\"hljs-property\">authorId</span>, usersSync.<span class=\"hljs-property\">id</span>));\n  <span class=\"hljs-keyword\">return</span> response[<span class=\"hljs-number\">0</span>] ? response[<span class=\"hljs-number\">0</span>] : <span class=\"hljs-literal\">null</span>;\n}\n</code></pre><ul>\n<li>Here we just added the where filter to filter it down to one record, the correct article ID.</li>\n<li>Drizzle doesn&#39;t have a select one function, but it&#39;s indexed so it&#39;s not a big deal.</li>\n<li>You&#39;ll notice that the two functions are quite similar, and there might be some DRY part of your brain twitching here, but I&#39;d say calm it and tell it that it&#39;s fine that we repeated ourselves. These two functions accomplish different things, and it&#39;s possible we could want to optimize them individually the future. There&#39;s no need for complex abstractions here, just have some WET (write everything twice/thrice) code here, no big deal.</li>\n<li>By the end of this project this will be the only data helper, but I like this pattern of having helpers to call database functions instead of just having the raw DB queries in your React UI - makes it a bit more centrally maintained that the UI access patterns and the underlying DB are maintained separately and can be modified either way without disturbing the other too much.</li>\n</ul>\n<p>Awesome! That&#39;s our SELECTs! Let&#39;s go do our writes!</p>\n","markdown":"Let's start by doing the SELECTS first. Our app is already pulling dummy data via a server helper function, so this makes it pretty simple as we only need to update this server helper as opposed to doing it in the code (and makes it super testable!)\n\nLet's open src/lib/data/articles.ts.\n\n```typescript\n// replace everything but the getArticlesById function - we'll do that in a sec\nimport db from \"@/db/index\";\nimport { articles } from \"@/db/schema\";\nimport { eq } from \"drizzle-orm\";\nimport { usersSync } from \"@/db/schema\"; // <- this is different from the video - it's the new path, or it can be combined with the above import\n\nexport async function getArticles() {\n  const response = await db\n    .select({\n      title: articles.title,\n      id: articles.id,\n      createdAt: articles.createdAt,\n      content: articles.content,\n      author: usersSync.name,\n    })\n    .from(articles)\n    .leftJoin(usersSync, eq(articles.authorId, usersSync.id));\n  return response;\n}\n```\n\n- We're first importing our db client. This is what will actually connect to the database.\n- We then import the articles schema. Why? This is how you reference which table you want to query. We want the articles table, so we import that schema.\n- In the function, we run a select, choose what columns we want, tell it which table it's coming from, and then join in the author's name (because we want to say the article was written by Bob, not \"user-12334\")\n- We added the where clause and used `eq` which, as you may imagine, checks for equality. Here we're saying we want to do the join on where the authorId in the article table is the same as the usersSync id so we can get a name instead of an ID.\n- And then we return the array of rows! That's it!\n- This does not paginate. But it's very easy to do with either [cursors][cursors] or just using limit() and offset like normal SQL. Feel free to implement this yourself!\n\n[cursors]: https://orm.drizzle.team/docs/guides/cursor-based-pagination\n\nThis should make articles on the home page pull from the database! Hooray! Let's make the articles page pull from it too.\n\n```typescript\nexport async function getArticleById(id: number) {\n  const response = await db\n    .select({\n      title: articles.title,\n      id: articles.id,\n      createdAt: articles.createdAt,\n      content: articles.content,\n      author: usersSync.name,\n      imageUrl: articles.imageUrl,\n    })\n    .from(articles)\n    .where(eq(articles.id, id))\n    .leftJoin(usersSync, eq(articles.authorId, usersSync.id));\n  return response[0] ? response[0] : null;\n}\n```\n\n- Here we just added the where filter to filter it down to one record, the correct article ID.\n- Drizzle doesn't have a select one function, but it's indexed so it's not a big deal.\n- You'll notice that the two functions are quite similar, and there might be some DRY part of your brain twitching here, but I'd say calm it and tell it that it's fine that we repeated ourselves. These two functions accomplish different things, and it's possible we could want to optimize them individually the future. There's no need for complex abstractions here, just have some WET (write everything twice/thrice) code here, no big deal.\n- By the end of this project this will be the only data helper, but I like this pattern of having helpers to call database functions instead of just having the raw DB queries in your React UI - makes it a bit more centrally maintained that the UI access patterns and the underlying DB are maintained separately and can be modified either way without disturbing the other too much.\n\nAwesome! That's our SELECTs! Let's go do our writes!\n","slug":"query-with-drizzle","title":"Query with Drizzle","section":"Database","icon":"database","filePath":"/home/runner/work/build-a-fullstack-nextjs-app-v4/build-a-fullstack-nextjs-app-v4/lessons/04-database/C-query-with-drizzle.md","nextSlug":"/lessons/database/writes-with-drizzle","prevSlug":"/lessons/database/setting-up-drizzle"}},"__N_SSG":true}